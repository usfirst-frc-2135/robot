// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#pragma once

#include <frc/commands/Subsystem.h>
#include <frc/Joystick.h>
#include <frc/controller/PIDController.h>
#include <frc/controller/SimpleMotorFeedforward.h>
#include <frc/kinematics/DifferentialDriveKinematics.h>
#include <frc/kinematics/DifferentialDriveOdometry.h>
#include <frc/controller/RamseteController.h>
#include <wpi/math>

#include <ctre/phoenix/sensors/PigeonIMU.h>

#include "frc2135/TalonUtils.h"
#include "frc2135/RobotConfig.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "ctre/Phoenix.h"
#include "frc/DoubleSolenoid.h"
#include "frc/drive/DifferentialDrive.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

using namespace units;
using namespace units::angle;
using namespace units::length;
using namespace units::literals;
using namespace units::time;
using namespace units::velocity;

/**
 *
 * @author ExampleAuthor
 */
class Drivetrain: public frc::Subsystem
{

private:
    // It's desirable that everything possible is private except
    // for methods that implement subsystem capabilities

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<WPI_TalonFX> motorL1;
	std::shared_ptr<WPI_TalonFX> motorR3;
	std::shared_ptr<frc::DifferentialDrive> diffDrive;
	std::shared_ptr<WPI_TalonFX> motorL2;
	std::shared_ptr<WPI_TalonFX> motorR4;
	std::shared_ptr<frc::DoubleSolenoid> shifter;
	std::shared_ptr<PigeonIMU> pigeonIMU;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    typedef enum driveMode_e
    {   // Driving Algorithms
        DRIVEMODE_FIRST      = 0,
        DRIVEMODE_ARCADE     = DRIVEMODE_FIRST,
        DRIVEMODE_CURVATURE  = 1,
        DRIVEMODE_VELCONTROL = 2,
        DRIVEMODE_LAST
    } driveMode_e;

    //    Declare constants
    const int       m_driveDebug = 0;               // Debug flag to disable extra logging calls
    const int       m_alignTurnDebug = 0;           // Debug flag to disable extra logging calls
    const int       kPidIndex = 0;                  // PID slot index for sensors
    const int       kCANTimeout = 30;               // CAN timeout in msec to wait for response

    const int       m_reqPigeonVer = ((20 * 256) + 0);   // Pigeon IMU version is 20.0

    // Drivetrain constants
    const double    kWheelDiaInches = 6.0;          // Measured wheel diameter
    const int       kEncoderCPR = (1024 * 4);       // CPR is 1024 and multiplied by 4 since quadrature
    const foot_t    kTrackWidthFeet = 2.125_ft;     // Measured track width

    // Derived values
    const double    kWheelCircumInches = kWheelDiaInches * wpi::math::pi;
    const double    kWheelCountsPerInch = kEncoderCPR / kWheelCircumInches;
    const foot_t    kEncoderFeetPerCount = foot_t(kWheelCircumInches / 12.0) / kEncoderCPR;

    const meter_t   kWheelDiameterMeters = 6.0_in;
    // Assumes the encoders are directly mounted on the wheel shafts
    const meter_t   kEncoderMetersPerCount =
        (kWheelDiameterMeters * wpi::math::pi) / static_cast<double>(kEncoderCPR);

    // Kinematics values for 2135 Bebula - 2019 B-bot
    static constexpr auto   ks = 0.899_V;
    static constexpr auto   kv = 1.411_V / 1_fps;
    static constexpr auto   ka = 0.21_V / 1_fps_sq;

    // As above, this must be tuned for your drive!
    static constexpr double kPDriveVel = 0.00291;

    const meters_per_second_t            kMaxSpeed = 1.1336_mps;
    const meters_per_second_squared_t    MaxAcceleration = 10.668_mps_sq;

    // Reasonable baseline values for a RAMSETE follower in meters and seconds
    const double            kRamseteB = 2.0;
    const double            kRamseteZeta = 0.7;

    // Declare module variables
    bool            m_talonValidL1;     // Health indicator for drive Talon Left 1
    bool            m_talonValidL2;     // Health indicator for drive Talon Left 2
    bool            m_talonValidR3;     // Health indicator for drive Talon Right 3
    bool            m_talonValidR4;     // Health indicator for drive Talon Right 4
    bool            m_pigeonValid;      // Health indicator for Pigeon IMU

    double          m_driveXScaling;    // Scaling applied to Joystick
    double          m_driveYScaling;    // Scaling applied to Joystick
    bool            m_throttleZeroed;   // Throttle joystick zeroed check for safety
    double          m_driveSpin;        // Spin turn power  setting

    bool            m_lowGear;          // Low Gear or High Gear
    bool            m_brakeMode;        // Brake or Coast Mode for Talons
    int             m_curDriveMode;     // Current driving mode, arcade by default
    bool            m_isQuickTurn;      // Setting for quickturn in curvature drive

    frc::Timer      m_safetyTimer;      // Safety timer for use during autonomous modes
    double          m_safetyTimeout;    // Time in seconds for safety timer
    bool            m_isMovingAuto;     // Indicates an auton movement is active

    // Drive distance Magic Motion settings
    double          m_distTargetInches; // Drive to Position target inches value
    double          m_distTargetCounts; // Drive to Position target counts value
    double          m_distTolInches;    // Tolerated error for MM PID loop

    // Drive turn PID settings
    double          m_turnAngle = 0.0;  // Desired turn angle from present course
    double          m_turnTolDeg;       // DriveTurn tolerance in degrees
    double          m_visionTurnKp;     // Proportional value for PID for Drive Turn with Vision-Assist
    double          m_turnMaxOut;       // Max motor output value for PID for DriveTurn function
	double          m_alignTurnTolerance; // Minimum align turn error to finish aligning
    double          m_alignTurnKp;
    double          m_alignTurnError;

    // Talon SRX settings for internal PID loop
    double          m_peakOut;          // Drivetrain maximum speed during movement
    int             m_velocity;         // Drivetrain motion velocity
    int             m_acceleration;     // Drivetrain motion acceleration
    int             m_sCurveStrength;   // Drivetrain motion S curve smoothing strength
    double          m_pidKp;            // Drivetrain PID proportional constant
    double          m_pidKi;            // Drivetrain PID integral constant
    double          m_pidKd;            // Drivetrain PID derivative constant

    double          m_openLoopRampRate;
    double          m_closedLoopRampRate;

    double          m_vcMaxSpeed;
    double          m_vcMaxAngSpeed;
    double          m_vcpidKp;
    double          m_vcpidKi;
    double          m_vcpidKd;

    const bool      kGyroReversed = true;

    // Odometry and telemetry
    int             m_encoderLeft = 0;      // Distance from Falcon - left side - counts
    int             m_encoderRight = 0;     // Distance from Falcon - right side - counts
    int             m_velocityLeft = 0;     // Velocity from Falcon - left side - counts/second
    int             m_velocityRight = 0;    // Velocity from Falcon - right side - counts/second
    double          m_currentl1 = 0.0;      // Motor L1 output current from Falcon
    double          m_currentL2 = 0.0;      // Motor L2 output current from Falcon
    double          m_currentR3 = 0.0;      // Motor R3 output current from Falcon
    double          m_currentR4 = 0.0;      // Motor R4 output current from Falcon
    double          m_headingDeg = 0.0;     // Pigeon IMU heading in degrees

    // Do another drive characterization
    frc::SimpleMotorFeedforward<meter>  m_feedforward {ks, kv, ka};
    frc::DifferentialDriveKinematics    m_kinematics {kTrackWidthFeet};
    frc::DifferentialDriveOdometry      *m_odometry;

    frc2::PIDController                 *m_leftPIDController;
    frc2::PIDController                 *m_rightPIDController;

    frc2::PIDController                 *driveVisionPIDLoop;   // Drive with Vision PID controller loop

    std::vector<frc::Trajectory::State> trajectoryStates;
    uint32_t                            trajCurState;

    frc2::PIDController                 *leftController;
    frc2::PIDController                 *rightController;
    frc::RamseteController              *ramseteController;

    ///////////////////////////////////////////////////////////////////////////

    void ConfigFileLoad(void);
    void TalonMasterInitialize(std::shared_ptr<WPI_BaseMotorController> motor);
    void TalonFollowerInitialize(std::shared_ptr<WPI_BaseMotorController> motor, int master);

    void UpdateOdometry(void);
    void UpdateDashboardValues(void);
    void UpdateMotorOutputs(void);

    // Brake or Coast Mode
    void MoveSetBrakeMode(bool m_brakeMode);

    // Conversion Functions
    void ResetSensors();
    double InchesToCounts(double inches);
    double CountsToInches(int counts);

    // Velocity Control Loop
    void VelocityCLDrive(const frc::DifferentialDriveWheelSpeeds& speeds);

    ///////////////////////////////////////////////////////////////////////////

    void TankDriveVolts(volt_t left, volt_t right);
    void ResetEncoders();
    meter_t GetAverageEncoderDistance();
    void SetMaxOutput(double maxOutput);
    double GetHeading();
    double GetTurnRate();
    frc::Pose2d GetPose();
    frc::DifferentialDriveWheelSpeeds GetWheelSpeeds();
    void ResetOdometry(frc::Pose2d pose);
    meter_t GetDistanceMeters(int encoderCounts);
    feet_per_second_t GetWheelSpeeds(int encoderCountsPerSecond);
    meters_per_second_t GetVelocityMPS(int encoderCountsPerSecond);

    // Pigeon IMU
    bool PigeonIMUInitialize();
    void PigeonIMUFaultDump(void);

public:
    Drivetrain();
    void InitDefaultCommand() override;
    void Periodic() override;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    void Initialize(void);
    void FaultDump(void);

    void BumpRampRate(bool bumpUp);
    void MoveSetQuickTurn(bool quickTurn);
    void MoveShiftGears(bool lowGear);
    void MoveSpin(bool spinRight);
    void MoveStop();
    void MoveWithJoysticks(std::shared_ptr<frc::Joystick>);
    void ToggleDriveMode();

    // Autonomous - Driving to a distance using Motion Magic
    void MoveDriveDistanceMMInit(double distance);
    void MoveDriveDistanceMMExecute(void);
    bool MoveDriveDistanceMMIsFinished(void);
    void MoveDriveDistanceMMEnd(void);

    // Autonomous - Aligning with Target Using Vision Processing
    void MoveAlignTurnInit(void);
    void MoveAlignTurnExecute(std::shared_ptr<frc::Joystick>);
    bool MoveAlignTurnIsFinished(void);
    void MoveAlignTurnEnd(void);

    // Autonomous - Ramsete follower command
    void RamseteFollowerInit(void);
    void RamseteFollowerExecute(void);
    bool RamseteFollowerIsFinished(void);
    void RamseteFollowerEnd(void);
};
